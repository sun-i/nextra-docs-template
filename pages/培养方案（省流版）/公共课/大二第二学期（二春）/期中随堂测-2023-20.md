题量： 38 满分： 100.0

考试时间：_2023-05-05 07:50_至_2023-05-05 09:20_

## 一. 单选题（共 29 题，58.0 分）

### 1. (单选题, 2.0 分) 一个进程执行下述代码：

for (i = 0; i < n; i++)

fork();

创建的子进程的数量（    ）。

- A. n
- B. ![](https://mooc1-api.chaoxing.com/ananas/latex/p/535345#id=BAMJZ&originHeight=19&originWidth=51&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
- C. ![](https://mooc1-api.chaoxing.com/ananas/latex/p/1542#id=HO8aj&originHeight=14&originWidth=14&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
- D. ![](https://mooc1-api.chaoxing.com/ananas/latex/p/72453#id=GV6WF&originHeight=18&originWidth=40&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

_我的答案:_D _正确答案:_ D

### 2. (单选题, 2.0 分)

下述哪些特征能够充分地刻画某个操作系统为多道程序操作系统？

（1）不止一个程序能够装载到内存中同时执行。

（2）如果一个程序等待某些事件，例如I/O，另外一个程序能够立即被调度执行。

（3）如果程序的执行结束，另一个程序立即被调度执行。

-  A. （1）&（2）&（3） 
-  B. （1） 
-  C. （1）&（3） 
-  D. （1）&（2） 

_我的答案:_D _正确答案:_ D

_答案解析：_

### 3. (单选题, 2.0 分)

Fetch_And_Add(X,i)是一个原子指令，它读取位于内存位置X的值，并增加i，同时返回X之前的值。下面使用一个伪代码来实现一个忙等待锁。L是一个无符号整数共享变量，初始化为0。0对应于锁可用，而非0对应于锁不可用。

AcquireLock() {

while (Fetch_And_Add(L, 1))

L = 1;

}

ReleaseLock() {

L = 0;

}

对于这个实现，下述正确的是（    ）。

- A. 由于在锁实际可用的时候L能够获取非0值，因此会失效。
- B. 由于L能够溢出，因此会失效。
- C. 可以正常工作，但是可能会促使某些进程产生饥饿。
- D. 可以正常工作，且没饥饿。

_我的答案:_B _正确答案:_ A

### 4. (单选题, 2.0 分) 计算机开机后，操作系统最终被加载到（  ）。

- A. RAM
- B. EPROM
- C. ROM
- D. BIOS

_我的答案:_A _正确答案:_ A

_答案解析：_

系统开机后，操作系统的程序会被自动加载到内存中的系统区，这段区域是RAM。

### 5. (单选题, 2.0 分)

序列（    ）是最优的非抢占调度序列，对于下述作业，它使得CPU空闲（    ）个单元时间。

![](https://p.ananas.chaoxing.com/star3/origin/a4cf24e4c65f0d780739aaab08e58096.png#id=Q9PNy&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

- A. {1,2,3},5
- B. {3,2,1},0
- C. {3,2,1},1
- D. {2,1,3},0

_我的答案:_C _正确答案:_ C

### 6. (单选题, 2.0 分)

下面程序包含3个并发进程和3个二进制信号量。

![](https://p.ananas.chaoxing.com/star3/origin/e3c4988df0d0ece6c349561a53eb453b.png#id=hNYWK&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

信号量初始为：S0=1, S1=0, S2=0

进程P0将打印多少次0？

- A. 至少两次
- B. 正好两次
- C. 正好三次
- D. 正好一次

_我的答案:_A _正确答案:_ A

### 7. (单选题, 2.0 分) 下列选项中，会导致进程从执行态变为就绪态的事件是（  ）。

- A. 执行P(wait)操作
- B. 启动I/O设备
- C. 被高优先级进程抢占
- D. 申请内存失败

_我的答案:_C _正确答案:_ C

_答案解析：_

P(wait)操作表示进程请求某一资源；被高优先级进程抢占只是被剥夺了处理机资源，进入就绪态，一旦得到处理机即可运行；其他项都因为请求某一资源会进入阻塞态

### 8. (单选题, 2.0 分)

下列（  ）应用工作最好采用实时操作系统平台。

Ⅰ、航空订票       Ⅱ、办公自动化       Ⅲ、机床控制

Ⅳ、AutoCAD     Ⅴ、工资管理系统    Ⅵ、股票交易系统

- A. Ⅰ、Ⅱ和Ⅲ
- B. Ⅰ、Ⅲ和Ⅳ
- C. Ⅰ、Ⅴ和Ⅵ
- D. Ⅰ、Ⅲ和Ⅵ

_我的答案:_D _正确答案:_ D

_答案解析：_

实时操作系统主要应用在需要对外界输入立即做出反应的场合，不能有拖延，否则会产生严重后果。

航空订票系统需要实时处理票务，因为票额数据库的数量直接反映了航班的可订机位。

机床控制也要实时，不然会出差错。

股票交易行情随时在变，若不能实时交易会出现时间差，使交易出现偏差。

### 9. (单选题, 2.0 分) 若某单处理器多进程系统中有多个就绪态进程，则下列关于处理机调度的叙述中，错误的是（  ）。

- A. 创建新进程后能进行处理机调度
- B. 在进程处于临界区时不能进行处理机调度
- C. 在进程结束时能进行处理机调度
- D. 在系统调用完成并返回用户态时能进行处理机调度

_我的答案:_B _正确答案:_ B

_答案解析：_

选项A、B、D显然属于可以进行处理机调度的情况。对于选项C，当进程处于临界区时,，说明进程正在占用处理机，只要不破坏临界资源的使用规则，就不会影响处理机的调度。比如，通常访问的临界资源可能是慢速的外设（如打印机)，若在进程访问打印机时，不能进行处理机调度，则系统的性能将非常差。

### 10. (单选题, 2.0 分) 一个计数信号量被初始化为10。在信号量上完成6次P操作和4次V操作之后，信号量的值为（   ）。

- A. 8
- B. 10
- C. 12
- D. 0

_我的答案:_A _正确答案:_ A

### 11. (单选题, 2.0 分) 对进程的管理和控制使用（  ）。

- A. 指令
- B. 信箱
- C. 信号量
- D. 原语

_我的答案:_D _正确答案:_ D

_答案解析：_

对进程的管理和控制功能是通过执行各种原语来实现的，如创建原语等。

### 12. (单选题, 2.0 分)

考虑使用P1和P2进程访问临界区的方法，如下所示。共享布尔变量S1和S2的初始值是随机分配的。

![](https://p.ananas.chaoxing.com/star3/origin/0c70b91c73afec8ee8797c617c383860.png#id=SGZP9&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

下面哪个陈述描述了系统的属性？

- A. 有互斥但没有进展
- B. 既不互斥，也没有进展
- C. 既互斥，也有进展
- D. 有进展但没有互斥

_我的答案:_A _正确答案:_ A

### 13. (单选题, 2.0 分) 提高单机资源利用率的关键技术是（  ）。

- A. 虚拟技术
- B. 多道程序设计技术
- C. 交换技术
- D. 脱机技术

_我的答案:_B _正确答案:_ B

_答案解析：_

脱机技术用于解决独占设备问题。

虚拟技术与交换技术以多道程序设计技术为前提。

多道程序设计技术由于同时在主存中运行多个程序，在一个程序等待时，可以去执行其他程序，因此提高了系统资源的利用率。

### 14. (单选题, 2.0 分)

下面为单处理器系统的进程状态转换图，假定总有一些进程处于就绪状态。

![](https://p.ananas.chaoxing.com/star3/origin/7134f60688337adfdf77e1a4c05f1fd1.png#id=I80am&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

现在考虑下述陈述：

Ⅰ、如果一个进程进行转换D，它将导致另一个进程立即进行转换A。

Ⅱ、当进程P1处于运行态时候，一个处于阻塞状态的进程P2进行转换E。

Ⅲ、OS使用抢占式调度。

Ⅳ、OS使用非抢占式调度。

上面哪些陈述为真？

- A. Ⅰ和Ⅲ
- B. Ⅱ和Ⅳ
- C. Ⅰ和Ⅱ
- D. Ⅱ和Ⅲ

_我的答案:_D _正确答案:_ B

_答案解析：_

### 15. (单选题, 2.0 分) 下面（  ）资源不是操作系统应该管理的。

- A. 源程序
- B. CPU
- C. 外存
- D. 内存

_我的答案:_A _正确答案:_ A

_答案解析：_

源程序是一种计算机代码，是用程序设计语言编写的程序，经编译或解释后可形成具有一定功能的可执行文件，是直接面向程序员用户的，而不是操作系统的管理内容。

本题采用排除法可轻易得到答案，但有人会问操作系统不是也管理“文件”吗?源程序也存储在文件中吧?出现这种疑问的原因是，对操作系统管理文件的理解存在偏颇。操作系统管理文件，是指操作系统关心计算机中的文件的逻辑结构、物理结构、文件内部结构、多文件之间如何组织的问题，而不是关心文件的具体内容。

这就好比你是操作系统，有十个水杯让你管理，你负责的是将这些水杯放在何处比较合适，而不关心水杯中的是水还是饮料。

### 16. (单选题, 2.0 分) 用户程序在用户态下要使用特权指令引起的中断属于（  ）。

- A. 外部中断
- B. 程序中断
- C. 访管中断
- D. 硬件故障中断

_我的答案:_C _正确答案:_ C

_答案解析：_

因操作系统不允许用户直接执行某些“危险性高”的指令，因此用户态运行这些指令的结果会转成操作系统的核心态去运行。这个过程就是访管中断或称自陷。

### 17. (单选题, 2.0 分) 系统调用是由操作系统提供给用户的，它（  ）。

- A. 直接通过键盘交互方式使用
- B. 是命令接口中的命令
- C. 只能通过用户程序间接使用
- D. 与系统的命令一样

_我的答案:_C _正确答案:_ C

_答案解析：_

系统调用是操作系统为应用程序使用内核功能所提供的接口。

### 18. (单选题, 2.0 分) 四个作业在单处理器系统上执行，都是在0时刻到达，顺序为A、B、C、D，它们burst时间需要分别为4, 1, 8, 1个时间单元。在时间片轮转调度（时间片为1）情况下，A的完成时间为：

- A. 8
- B. 4
- C. 9
- D. 10

_我的答案:_C _正确答案:_ C

### 19. (单选题, 2.0 分) CPU处于核心态时，它可以执行的指令是（  ）。

- A. 除“访管”指令的全部指令
- B. 只有特权指令
- C. 只有“访管”指令
- D. 只有非特权指令

_我的答案:_A _正确答案:_ A

_答案解析：_

访管指令在用户态下使用，是用户程序“自愿进管”的手段，用户态下不能执行特权指令。在核心态下，CPU可以执行指令系统中的任何指令。

### 20. (单选题, 2.0 分)

下列关于操作系统的说法中,错误的是（  ）。

Ⅰ、在通用操作系统管理下的计算机上运行程序，需要向操作系统预定运行时间

Ⅱ、在通用操作系统管理下的计算机上运行程序，需要确定起始地址，并从这个地址开始执行

Ⅲ、操作系统需要提供高级程序设计语言的编译器

Ⅳ、管理计算机系统资源是操作系统关心的主要问

- A. Ⅰ、Ⅱ、Ⅲ、Ⅳ
- B. 以上答案都正确
- C. Ⅰ、Ⅲ
- D. Ⅱ、Ⅲ

_我的答案:_C _正确答案:_ C

_答案解析：_

Ⅰ：通用操作系统使用时间片轮转调度算法，用户运行程序并不需要预先预定运行时间，错误

Ⅱ：操作系统执行程序时，必须从起始地址开始执行，正确

Ⅲ：编译器是操作系统的上层软件，不是操作系统需要提供的功能，错误

Ⅳ：操作系统是计算机资源的管理者，管理计算机系统资源是操作系统关心的主要问题，正确。

### 21. (单选题, 2.0 分) （  ）有利于CPU密集型的作业，而不利于I/O密集型的作业。

- A. 先来先服务调度算法
- B. 时间片轮转调度算法
- C. 优先权调度算法
- D. 短作业（进程）优先算法

_我的答案:_A _正确答案:_ A

_答案解析：_

先来先服务（FCFS）调度算法是一种最简单的调度算法，在作业调度中采用该算法时，每次调度从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。

FCFS调度算法比较有利于长作业，而不利于短作业。所谓CPU密集型的作业，是指该类作业需要大量的CPU时间进行计算，而很少请求I/O操作。I/O密集型的作业是指CPU处理时，需频繁地请求I/O操作。所以CPU密集型作业更接近于长作业。

### 22. (单选题, 2.0 分)

Linux系统下，考虑下述代码：

if (fork() == 0) {

a = a + 5;

printf("%d,%d\n", a, &a);

} else {

a = a – 5;

printf("%d,%d\n", a, &a);

}

令u和v分别是父进程打印出来的值，x和y是子进程打印出来的值。下述哪个说法正确？

- A. u + 10 = x，并且 v = y
- B. u = x + 10，并且 v != y
- C. u = x + 10，并且 v = y
- D. u + 10 = x，并且 v != y

_我的答案:_A _正确答案:_ A

### 23. (单选题, 2.0 分)

两个进程P1和P2需要访问临界区的代码。考虑进程代码如下。

![](https://p.ananas.chaoxing.com/star3/origin/9afc7b253a72e7edf8c58956eab786ee.png#id=Zj97K&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

这里wants1 和 wants2是共享变量，初始为false。关于代码下面哪个陈述为真？

- A. 它并不预防死锁，但是确保互斥
- B. 它需要进程按照严格的交替顺序进入临界区
- C. 它并不确保有限等待（bounded waiting）
- D. 它并不确保互斥

_我的答案:_B _正确答案:_ A

### 24. (单选题, 2.0 分) 系统调用通常通过使用（    ）来调用。

- A. 特权指令
- B. 间接跳转
- C. 轮询
- D. 软件中断

_我的答案:_D _正确答案:_ D

### 25. (单选题, 2.0 分)

实现临界区访问的enter_CS() 和leave_CS()函数使用test-and-set指令实现如下：

void enter_CS() {

while(test-and-set(&X));

}

void leave_CS() {

X = 0;

}

在上述解决方案中，X是与CS相关联的内存变量，初始化为0。现在下述陈述，哪些为真？

（1）上述对临界区（CS）问题的解决方案是免于死锁的。

（2）方案免于饥饿。

（3）进程按照FIFO的顺序进入CS。

（4）在同一时刻不止一个进程能够进入临界区。

- A. （1）&（2）
- B. 只有（1）
- C. （2）&（3）
- D. 只有（4）

_我的答案:_C _正确答案:_ B

### 26. (单选题, 2.0 分) 当操作系统从进程A切换到进程B，通常不会执行下述哪个行为？

- A. 将进程A的内存镜像对换到磁盘上。
- B. 改变地址翻译表。
- C. 保存当前寄存器的值，并恢复进程B所保存的寄存器的值。
- D. 清除地址翻译快表缓冲。

_我的答案:_D _正确答案:_ A

### 27. (单选题, 2.0 分) 在多对一的线程模型中，当一个多线程进程中的某个线程被阻塞后，（  ）。

- A. 该阻塞线程将永远不可能再执行
- B. 整个进程都将阻塞
- C. 该进程的其他线程仍可继续运行
- D. 该阻塞线程将被撤销

_我的答案:_B _正确答案:_ B

_答案解析：_

在多对一的线程模型中，用户级线程的“多”对操作系统透明，即操作系统并不知道用户有多少线程。因此该进程的一个线程被阻塞后，该进程就被阻塞，进程的其他线程当然也都被阻塞。

### 28. (单选题, 2.0 分) 一个应用程序包括几个进程：一个主进程和一些子进程。如果（    ），这种安排便能够加速计算。

- A. 计算机系统具有多个CPU。
- B. 某些进程受CPU限制。
- C. 以上都不是。
- D. 一些进程受I/O限制。

_我的答案:_A _正确答案:_ A

_答案解析：_

### 29. (单选题, 2.0 分) 在分时系统中，时间片一定时，（   ）响应时间越长。

- A. 内存越少
- B. 用户数越少
- C. 内存越多
- D. 用户数越多

_我的答案:_D _正确答案:_ D

_答案解析：_

分时系统中，当时间片固定时，用户数越多，每个用户分到的时间片就越少，响应时间自然就变长。

注意，分时系统的响应时间T的比例关系可表达为T≈QN，其中Q是时间片，而N是用户数。

## 二. 判断题（共 5 题，10.0 分）

### 30. (判断题, 2.0 分) 无论是在单处理器或者多处理器系统中，内核级线程比用户级线程提供更好的并发性。

- A. 对
- B. 错

_我的答案:_ 对 _正确答案:_ 对

_答案解析：_

### 31. (判断题, 2.0 分) 处理完事件后，如果没有任何进程状态发生更改，则内核无需在分派之前执行调度。

- A. 对
- B. 错

_我的答案:_ 对 _正确答案:_ 对

_答案解析：_

### 32. (判断题, 2.0 分) 当进程的用户级线程进行导致阻塞的系统调用时，该进程的所有线程都将被阻塞。

- A. 对
- B. 错

_我的答案:_ 对 _正确答案:_ 对

_答案解析：_

### 33. (判断题, 2.0 分) 由于请求某个资源而被阻塞的进程，当获得资源的时候，将改变为运行状态

- A. 对
- B. 错

_我的答案:_ 错 _正确答案:_ 错

_答案解析：_

### 34. (判断题, 2.0 分) 当进程终止时，应记住其终止代码，直到其父进程终止。

- A. 对
- B. 错

_我的答案:_ 对 _正确答案:_ 错

_答案解析：_

## 三. 简答题（共 4 题，32.0 分）

### 35. (简答题, 8.0 分)

一个并发程序包含一个共享变量x。变量x出现在如下代码段中：

if (x < c) y = x;

else  y = x +10;

printf("%d, %d", x, y);

该程序具有竞争条件吗？给出你的理由。

_我的答案：_

竞争条件是指两个或两个以上的进程读取某个共享的数据，而最后的结果取决于进程运行的先后顺序。该程序具有竞争条件，因为多个进程同时进入该程序后，如果存在输入的x,y,c不同，有可能会使得线程进入程序后需要执行的代码不同，例如一个线程执行if语句，另一个线程执行else语句，此时打印出的x,y的值取决于进程执行的快慢。

_正确答案：_

如果两个进程可以同时更新代码中的某些变量，则两个并发进程会导致竞争状态。

临界区用于避免竞争条件和不可预测的结果。临界区是一个代码段，对于共享数据，该代码段不能与其他临界区或与其自身同时执行。

考虑一个并发程序，该程序在几个地方更新共享变量x，这些更新放置在临界区。

问题中给出的代码部分（不是临界区）不会更新变量x，而只会读取变量x。尽管语句确实更新了变量y，但它不是共享变量。因此，使用给定的信息，这些语句不满足临界区的条件，也不会引起竞争条件。

### 36. (简答题, 8.0 分)

有如下代码，提供的多线程调用，但是存在问题，请修正之。

typedef struct _node_t {

int key;

struct _node_t *next;

} node_t;

mutex_t m = PTHREAD_MUTEX_INITIALIZER;

node_t *head = NULL;

int listInsert(int key) {

mutex_lock(&m) ;

node_t *n = malloc(sizeof(node_t));

if (n== NULL) {  return -1; }  //申请堆失败，返回

n->key = key ;

n->next = head;

head= n;   // 在头部加入

mutex_unlock(&m) ;

return 0;    // 成功返回

}

_我的答案：_

在n->next = head前加上mutex_lock(&m);

_正确答案：_

在申请堆失败时，返回之前必须释放锁，所以在return -1之前加上：

mutex_unlock(&m) ;

如果将mutex_lock(&m) ;放在申请内存之后插入节点之前，可以避免失败后释放锁，但对于内存资源来说，存在申请后而可能暂时不能使用。

_答案解析：_

### 37. (简答题, 8.0 分)

两个并发进程共享一个数据项sum，它初始值为0。每个进程包含一个执行50次循环，循环体为：

sum = sum +1

如果sum上没有其他的操作，请给出当两个进程执行完毕后，sum可能的值的上下限。

_我的答案：_

sum的值的取值范围可能在2~100之间

_正确答案：_

如果两个并发进程之间的共享代码没有使相关代码互斥，则可能导致竞争。互斥确保数据同步。没有它，就无法获得理想的结果。

考虑两个并发进程P1和P2，它们将变量的值加1（已初始化为0）。每个进程执行一次循环50次。给定的增量语句将通过load，add和store指令序列来实现。考虑所有情况都顺利进行且两个进程都将一个和另一个初始化为0的情况。处理P1执行add语句50次，因此sum的值为50。下一个进程执行50次add语句。因此总和的值变为100。

考虑在执行期间切换进程的所有情况。切换过程最终终止时，sum变量的值介于50到100之间。比如，最初进程P1将sum初始化为0，并执行其50次add，因此sum的值为50；现在进程P2运行，将sum初始化为0，它运行后，sum的值为50。

因此，两个过程终止时变量sum的上限和下限分别为100和50。

### 38. (简答题, 8.0 分)

假设有个代码序列，如下所示，分别由两个线程在单处理器上几乎在同一时间执行：

mutex_lock();

do_something() ;  // 无需时间即可执行

mutex_unlock ();

exit( );                   // 无需时间即可执行

（1）在这个CPU上的两个线程完成这个代码序列的最佳情况下时间是多少？

（2）这两个线程完成这个代码序列的最坏情况下时间是多少？假设最多只能发生三次上下文切换。

（3）如果将自旋锁改为基于队列的锁，对于第2问中的最坏情况下有何改变？

_我的答案：_

（1）最佳情况下当两个进程执行时间完全相同时，完成的时间最短，所需要的时间为do_something()所需要的时间。

（2）最坏情况下是两个线程交替执行需要执行的代码序列.当两个线程执行时间不同时，需要时间为 a*(do_something()+max(mutex_lock(),mutex_unlock());当线程执行时间相同时，需要的时间为a*(do_something()+mutex_lock()+mutex_unlock()),a为执行次数

（3）在这种情况下，最坏的情况的时间会变为不超过（2）中两个进程执行时间相等的时间

_正确答案：_

假设申请锁时长A，释放锁时长B

（1）依次完成，比如 T1-->T2

A-B-C-A-B=2A+2B+C

（2）在T1获得锁后时间片到，T2占用时间片自旋等待至时间片到，T1完成后切换到T2，T2获得锁后完成。

A-C-T-C-B-C-A-B=2A+2B+3C+T

（3）采用队列后，T2会阻塞让出，2A+2B+3C
